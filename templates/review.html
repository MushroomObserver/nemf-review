<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEMF Photo Review</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            color: #eee;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 800px;
            grid-template-rows: auto 1fr;
            height: 100vh;
            gap: 10px;
            padding: 10px;
        }
        header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #16213e;
            padding: 10px 20px;
            border-radius: 8px;
        }
        .progress {
            display: flex;
            gap: 20px;
            font-size: 14px;
        }
        .progress span { color: #888; }
        .progress .count { color: #4ecca3; font-weight: bold; }
        .image-panel {
            background: #0f0f23;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .image-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            overflow: hidden;
            cursor: zoom-in;
        }
        .image-container img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 4px;
        }
        .adjacent-strip {
            background: #16213e;
            padding: 10px;
        }
        .adjacent-strip-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
            color: #888;
        }
        .adjacent-images {
            display: flex;
            gap: 5px;
            overflow-x: auto;
        }
        .adjacent-thumb {
            position: relative;
            flex-shrink: 0;
        }
        .adjacent-thumb img {
            height: 60px;
            width: 80px;
            object-fit: cover;
            border-radius: 4px;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        .adjacent-thumb img:hover { opacity: 1; }
        .adjacent-thumb.current img {
            opacity: 1;
            border: 2px solid #4ecca3;
        }
        .adjacent-thumb.peeking img {
            opacity: 1;
            border: 2px solid #feca57;
        }
        .adjacent-thumb .link-btn {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: #4ecca3;
            color: #000;
            border: none;
            border-radius: 3px;
            font-size: 10px;
            padding: 2px 5px;
            cursor: pointer;
            display: none;
        }
        .adjacent-thumb:hover .link-btn,
        .adjacent-thumb.peeking .link-btn {
            display: block;
        }
        .adjacent-thumb .thumb-code {
            position: absolute;
            top: 2px;
            left: 2px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            font-size: 9px;
            padding: 1px 4px;
            border-radius: 2px;
            max-width: 75px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .data-panel {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .two-column-layout {
            display: grid;
            grid-template-columns: 350px 400px;
            gap: 15px;
        }
        .left-column, .right-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .section {
            background: #1a1a2e;
            border-radius: 6px;
            padding: 15px;
        }
        .section h3 {
            margin: 0 0 10px 0;
            font-size: 12px;
            text-transform: uppercase;
            color: #888;
            letter-spacing: 1px;
        }
        .field {
            margin-bottom: 12px;
        }
        .field label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #888;
            margin-bottom: 4px;
            text-transform: uppercase;
        }
        .field-with-lock {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .field-with-lock > input[type="text"],
        .field-with-lock > select {
            flex: 1;
            width: 0;
            min-width: 0;
        }
        .field-with-lock > .autocomplete-wrapper {
            flex: 1;
            min-width: 0;
        }
        .field-lock {
            width: 16px;
            height: 16px;
            min-width: 16px;
            max-width: 16px;
            cursor: pointer;
            margin: 0;
            padding: 0;
            flex: 0 0 16px;
            accent-color: #4ecca3;
        }
        .field-lock:checked {
            accent-color: #feca57;
        }
        .field .value {
            font-size: 14px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .field .value.missing { color: #ff6b6b; font-style: italic; }
        .field .value.low-confidence { color: #feca57; }
        .field input, .field select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #0f0f23;
            color: #fff;
            font-size: 14px;
        }
        .field input:focus, .field select:focus {
            outline: none;
            border-color: #4ecca3;
        }
        .match-indicator {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            font-size: 11px;
            font-weight: bold;
        }
        .match-exact {
            background: #4ecca3;
            color: #000;
        }
        .match-partial {
            background: #feca57;
            color: #000;
        }
        .match-none {
            background: #ff6b6b;
            color: #fff;
        }
        .existing-obs {
            background: #2d3436;
            padding: 8px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        .existing-obs a { color: #74b9ff; }
        .linked-image-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 8px;
            background: #2d3436;
            border-radius: 3px;
            margin-bottom: 4px;
        }
        .linked-image-name {
            flex: 1;
            font-size: 12px;
            color: #4ecca3;
        }
        .btn-unlink {
            background: #ff6b6b;
            color: #fff;
            border: none;
            border-radius: 3px;
            padding: 2px 8px;
            font-size: 10px;
            cursor: pointer;
            margin-left: 8px;
        }
        .btn-unlink:hover {
            opacity: 0.8;
        }
        .actions {
            display: flex;
            gap: 10px;
            margin-top: auto;
            padding-top: 15px;
        }
        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: transform 0.1s, opacity 0.1s;
        }
        button:hover { opacity: 0.9; }
        button:active { transform: scale(0.98); }
        .btn-approve { background: #4ecca3; color: #000; }
        .btn-exclude { background: #ff6b6b; color: #fff; }
        .btn-skip { background: #555; color: #fff; }
        .btn-already-on-mo { background: #74b9ff; color: #000; }
        .btn-mo-phase4 { background: #a29bfe; color: #000; }
        .btn-mo-phase5 { background: #fd79a8; color: #000; }
        .btn-search-mo { background: #00b894; color: #fff; }
        .mo-status-success { background: #4ecca3; color: #000; }
        .mo-status-error { background: #ff6b6b; color: #fff; }
        .mo-status-loading { background: #feca57; color: #000; }
        .nav-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .btn-nav {
            background: #333;
            color: #fff;
        }
        .status-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            text-transform: uppercase;
            font-weight: bold;
        }
        .status-approved { background: #4ecca3; color: #000; }
        .status-corrected { background: #feca57; color: #000; }
        .status-excluded { background: #ff6b6b; color: #fff; }
        .status-already_on_mo { background: #74b9ff; color: #000; }
        .uploaded-warning {
            background: #fd79a8;
            color: #000;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 13px;
            border: 2px solid #e84393;
        }
        .uploaded-warning a {
            color: #000;
            text-decoration: underline;
        }
        /* Zoom modal */
        .zoom-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            cursor: zoom-out;
            overflow: auto;
        }
        .zoom-modal.active { display: flex; align-items: center; justify-content: center; }
        .zoom-modal img {
            max-width: 95vw;
            max-height: 95vh;
            object-fit: contain;
        }
        .zoom-label {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
        }
        /* Peek panel for viewing adjacent image details */
        .peek-panel {
            display: none;
            background: #2d3436;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            border: 2px solid #feca57;
        }
        .peek-panel.active { display: block; }
        .peek-panel h4 {
            margin: 0 0 8px 0;
            color: #feca57;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .peek-panel .peek-data {
            font-size: 13px;
        }
        .peek-panel .peek-data div {
            margin: 4px 0;
        }
        .peek-panel .peek-actions {
            margin-top: 10px;
            display: flex;
            gap: 8px;
        }
        .peek-panel button {
            padding: 6px 12px;
            font-size: 12px;
        }
        .btn-link { background: #4ecca3; color: #000; }
        .btn-close-peek { background: #555; color: #fff; flex: 0; padding: 6px 10px; }
        /* Modal base styles */
        .modal, .jump-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal.active, .jump-modal.active { display: flex; }
        .modal-content, .jump-content {
            background: #16213e;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
        }
        .modal-content h2, .jump-content h2, .jump-content h3 { margin-top: 0; }
        .jump-content {
            width: 400px;
            padding: 20px;
        }
        .jump-content input {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #0f0f23;
            color: #fff;
        }
        .candidate {
            padding: 8px 10px;
            background: #2d3436;
            border-radius: 3px;
            margin: 4px 0;
            cursor: pointer;
        }
        .candidate:hover {
            background: #4ecca3;
            color: #000;
        }
        /* Autocomplete dropdown */
        .autocomplete-wrapper {
            position: relative;
        }
        .field > .autocomplete-wrapper {
            width: 100%;
        }
        .autocomplete-wrapper input {
            width: 100%;
        }
        .autocomplete-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #1a1a2e;
            border: 1px solid #4ecca3;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
        }
        .autocomplete-dropdown.active { display: block; }
        .autocomplete-item {
            padding: 8px 10px;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 1px solid #333;
        }
        .autocomplete-item:last-child { border-bottom: none; }
        .autocomplete-item:hover, .autocomplete-item.selected {
            background: #4ecca3;
            color: #000;
        }
        .autocomplete-item .match-type {
            font-size: 10px;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 8px;
        }
        .autocomplete-item .match-type.exact { background: #4ecca3; color: #000; }
        .autocomplete-item .match-type.partial { background: #feca57; color: #000; }
        .autocomplete-item .match-type.candidate { background: #74b9ff; color: #000; }
        /* Field verification indicator */
        .field-status {
            display: inline-block;
            margin-left: 8px;
            font-size: 11px;
        }
        .field-status.verifying { color: #feca57; }
        .field-status.verified { color: #4ecca3; }
        .field-status.unverified { color: #ff6b6b; }
        /* Already on MO modal */
        .radio-group {
            display: flex;
            gap: 20px;
            margin: 15px 0;
        }
        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .radio-option input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .radio-option label {
            cursor: pointer;
            font-size: 14px;
        }
        .mo-id-input {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #0f0f23;
            color: #fff;
            margin-top: 10px;
        }
        .verification-status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            font-size: 13px;
        }
        .verification-status.verifying {
            background: #feca57;
            color: #000;
        }
        .verification-status.success {
            background: #4ecca3;
            color: #000;
        }
        .verification-status.error {
            background: #ff6b6b;
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div>
                <strong>NEMF Photo Review</strong>
                <span id="currentFilename" style="margin-left: 15px; color: #888;"></span>
                <span id="claimStatus" style="margin-left: 10px;"></span>
            </div>
            <div class="progress">
                <span>Total: <span class="count" id="totalCount">0</span></span>
                <span>Reviewed: <span class="count" id="reviewedCount">0</span></span>
                <span>Approved: <span class="count" id="approvedCount">0</span></span>
                <span>On MO: <span class="count" id="alreadyOnMOCount">0</span></span>
                <span>Excluded: <span class="count" id="excludedCount">0</span></span>
                <span>Position: <span class="count" id="positionInfo">0/0</span></span>
                <span style="margin-left: 20px;">User: <span class="count" id="currentUser">-</span></span>
            </div>
            <div style="display: flex; gap: 15px; font-size: 12px;">
                <a id="projectChecklistLink" href="#" target="_blank" style="color: #74b9ff;">Project Checklist</a>
                <a href="#" onclick="showSettings(); return false;" style="color: #74b9ff;">Settings</a>
            </div>
        </header>

        <div class="image-panel">
            <div class="image-container" onclick="zoomImage()">
                <img id="mainImage" src="" alt="Review image">
            </div>
            <div class="adjacent-strip">
                <div class="adjacent-strip-header">
                    <span>Adjacent Images (click to peek, use "Link" to copy field data)</span>
                    <span id="peekingIndicator" style="color: #feca57; display: none;">üëÅ Peeking</span>
                </div>
                <div class="adjacent-images" id="adjacentImages"></div>
            </div>
        </div>

        <div class="data-panel">
            <!-- Two-column layout -->
            <div class="two-column-layout">
                <!-- Left column: Review/Corrections -->
                <div class="left-column">
                    <div class="section">
                        <h3>Review / Corrections <span id="statusBadge"></span></h3>
                <div class="field">
                    <label>Field Slip Code <a id="reviewFieldSlipLink" href="#" target="_blank" style="color: #74b9ff; font-size: 11px; display: none;">View on MO</a></label>
                    <div class="field-with-lock">
                        <input type="checkbox" class="field-lock" id="lockFieldCode" title="Lock field to prevent override from linked images">
                        <input type="text" id="reviewFieldCode" placeholder="NEMF-XXXXX" oninput="updateReviewFieldSlipLink(); onFieldInput('reviewFieldCode', 'lockFieldCode')">
                    </div>
                </div>
                <div class="field">
                    <label>Date</label>
                    <div class="field-with-lock">
                        <input type="checkbox" class="field-lock" id="lockDate" title="Lock field to prevent override from linked images">
                        <select id="reviewDate" onchange="onFieldInput('reviewDate', 'lockDate')">
                            <option value="">-- Select date --</option>
                            <option value="2025-09-17">2025-09-17 (Wed)</option>
                            <option value="2025-09-18">2025-09-18 (Thu)</option>
                            <option value="2025-09-19">2025-09-19 (Fri)</option>
                            <option value="2025-09-20">2025-09-20 (Sat)</option>
                            <option value="2025-09-21">2025-09-21 (Sun)</option>
                            <option value="other">Other...</option>
                        </select>
                    </div>
                    <input type="date" id="reviewDateCustom" style="display: none; margin-top: 5px;" oninput="onFieldInput('reviewDateCustom', 'lockDate')">
                </div>
                <div class="field">
                    <label>
                        Location
                        <span class="field-status" id="locationStatus"></span>
                    </label>
                    <div class="field-with-lock">
                        <input type="checkbox" class="field-lock" id="lockLocation" title="Lock field to prevent override from linked images">
                        <div class="autocomplete-wrapper">
                            <input type="text" id="reviewLocation" placeholder="Start typing..." autocomplete="off" oninput="onFieldInput('reviewLocation', 'lockLocation')">
                            <div class="autocomplete-dropdown" id="locationDropdown"></div>
                        </div>
                    </div>
                    <input type="hidden" id="reviewLocationId">
                </div>
                <div class="field">
                    <label>
                        ID (Name)
                        <span class="field-status" id="nameStatus"></span>
                    </label>
                    <div class="field-with-lock">
                        <input type="checkbox" class="field-lock" id="lockName" title="Lock field to prevent override from linked images">
                        <div class="autocomplete-wrapper">
                            <input type="text" id="reviewName" placeholder="Start typing..." autocomplete="off" oninput="onFieldInput('reviewName', 'lockName')">
                            <div class="autocomplete-dropdown" id="nameDropdown"></div>
                        </div>
                    </div>
                    <input type="hidden" id="reviewNameId">
                </div>
                <div class="field">
                    <label>Notes</label>
                    <div class="field-with-lock">
                        <input type="checkbox" class="field-lock" id="lockNotes" title="Lock field to prevent override from linked images">
                        <input type="text" id="reviewNotes" placeholder="Additional notes..." oninput="onFieldInput('reviewNotes', 'lockNotes')">
                    </div>
                </div>
                <div class="field" id="linkedImagesField" style="display: none;">
                    <label>Linked Images</label>
                    <div id="linkedImagesList" style="font-size: 12px; color: #4ecca3;"></div>
                </div>
                <div id="reviewExistingObsContainer" style="display: none; margin-top: 10px;">
                    <label style="font-size: 11px; color: #888; text-transform: uppercase;">Existing MO Observation</label>
                    <div class="existing-obs" id="reviewExistingObs"></div>
                </div>
                <div style="margin-top: 15px;">
                    <button class="btn-search-mo" onclick="searchMO()" style="width: 100%;">üîç Search MO</button>
                </div>
                    </div>
                </div>

                <!-- Right column: Nav/Actions/Upload/Peek/Extracted -->
                <div class="right-column">
                    <!-- Navigation buttons -->
                    <div style="display: flex; gap: 10px;">
                        <button class="btn-nav" id="btnBack" onclick="backImage()" style="flex: 1;">‚Üê Back</button>
                        <button class="btn-nav" id="btnForward" onclick="forwardImage()" style="flex: 1;">Forward ‚Üí</button>
                        <button class="btn-nav" onclick="jumpToImage()" style="flex: 1;">Jump</button>
                        <button class="btn-nav" id="btnNextUnreviewed" onclick="nextUnreviewedImage()" style="flex: 1;">Next Unreviewed ‚è≠</button>
                    </div>

                    <!-- Action buttons -->
                    <div style="display: flex; gap: 10px;">
                        <button class="btn-already-on-mo" onclick="openAlreadyOnMOModal()" style="flex: 1;">Already on MO</button>
                        <button class="btn-exclude" onclick="confirmExclude()" style="flex: 1;">Exclude</button>
                    </div>

                    <!-- Reset button -->
                    <div style="margin-top: 10px;">
                        <button class="btn-skip" onclick="resetReview()" style="width: 100%; font-size: 12px;">Reset to Unreviewed</button>
                    </div>

                    <!-- Upload to MO section -->
                    <div class="section" id="moUploadSection">
                        <h3>Upload to MO</h3>
                        <div id="alreadyUploadedWarning" class="uploaded-warning" style="display: none;">
                            ‚ö†Ô∏è This image has already been uploaded to MO
                        </div>
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <button class="btn-mo-phase4" onclick="openPhase4Modal()" style="flex: 1;">
                                Add to Existing Observation
                            </button>
                            <button class="btn-mo-phase5" onclick="uploadPhase5()" style="flex: 1;">
                                Create New Observation
                            </button>
                        </div>
                        <div id="moUploadStatus" style="display: none; padding: 10px; border-radius: 4px; font-size: 12px; margin-top: 10px;"></div>
                    </div>

                    <!-- Peek panel -->
                    <div class="peek-panel" id="peekPanel">
                        <h4>
                            <span>Peeking: <span id="peekFilename"></span></span>
                            <button class="btn-close-peek" onclick="closePeek()">‚úï</button>
                        </h4>
                        <div class="peek-data">
                            <div><strong>Field Code:</strong> <span id="peekFieldCode">-</span> <a id="peekFieldSlipLink" href="#" target="_blank" style="color: #74b9ff; font-size: 11px; display: none;">View on MO</a></div>
                            <div><strong>Date:</strong> <span id="peekDate">-</span></div>
                            <div><strong>Location:</strong> <span id="peekLocation">-</span></div>
                            <div><strong>ID:</strong> <span id="peekName">-</span></div>
                            <div><strong>Claim:</strong> <span id="peekClaimStatus">-</span></div>
                        </div>
                        <div class="peek-actions">
                            <button class="btn-link" onclick="linkFromPeek()">
                                Link Data to Current Image
                            </button>
                            <button class="btn-nav" onclick="switchToPeek()">
                                Switch to This Image
                            </button>
                        </div>
                    </div>

                    <!-- Extracted Data section -->
                    <div class="section">
                        <h3>Extracted Data</h3>
                        <div class="field">
                            <label>Field Slip Code</label>
                            <div class="value">
                                <span id="sourceFieldCode">-</span>
                                <a id="fieldSlipLink" href="#" target="_blank" style="color: #74b9ff; font-size: 12px; margin-left: 10px; display: none;">View on MO</a>
                            </div>
                        </div>
                        <div class="field">
                            <label>Date</label>
                            <div class="value" id="sourceDate">-</div>
                        </div>
                        <div class="field">
                            <label>
                                Location
                                <span class="match-indicator" id="locationMatchIndicator" title=""></span>
                            </label>
                            <div class="value" id="sourceLocation">-</div>
                        </div>
                        <div class="field">
                            <label>
                                ID (Name)
                                <span class="match-indicator" id="nameMatchIndicator" title=""></span>
                            </label>
                            <div class="value" id="sourceName">-</div>
                        </div>
                        <div class="field">
                            <label>Notes</label>
                            <div class="value" id="sourceNotes" style="font-size: 12px; color: #888;">-</div>
                        </div>
                        <div id="existingObsContainer" style="display: none;">
                            <label style="font-size: 11px; color: #888; text-transform: uppercase;">Existing MO Observation</label>
                            <div class="existing-obs" id="existingObs"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Zoom modal -->
    <div class="zoom-modal" id="zoomModal" onclick="closeZoom()">
        <div class="zoom-label" id="zoomLabel"></div>
        <img id="zoomImage" src="">
    </div>

    <!-- Jump to image modal -->
    <div class="jump-modal" id="jumpModal" onclick="closeJumpModal()">
        <div class="jump-content" onclick="event.stopPropagation()">
            <h3>Jump to Image</h3>
            <input type="text" id="jumpInput" placeholder="Enter exact filename (e.g., IMG_5163.jpeg)" onkeydown="handleJumpInput(event)">
            <div id="jumpError" style="margin-top: 10px; color: #ff6b6b; display: none;"></div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-approve" onclick="executeJump()">Jump</button>
                <button class="btn-exclude" onclick="closeJumpModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Settings modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h2>Settings</h2>
            <div class="field">
                <label>Username</label>
                <input type="text" id="settingsUsername" disabled style="background: #333;">
            </div>
            <div class="field" style="margin-top: 15px;">
                <label>MO API Key</label>
                <input type="text" id="settingsApiKey" placeholder="Your MO API key...">
                <p style="font-size: 11px; color: #888; margin-top: 5px;">
                    Get your API key from <a id="apiKeyLink" href="#" target="_blank" style="color: #74b9ff;">MO Account Settings</a>
                </p>
            </div>
            <div class="field" style="margin-top: 15px;">
                <label>New Password (leave blank to keep current)</label>
                <input type="password" id="settingsPassword" placeholder="New password...">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-approve" onclick="saveSettings()">Save</button>
                <button class="btn-skip" onclick="closeSettings()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Claim conflict modal -->
    <div class="modal" id="claimConflictModal">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h2 style="color: #ff6b6b;">Cannot Claim Image</h2>
            <p id="claimConflictMessage">This image is being reviewed by another user.</p>
            <div id="claimConflictDetails" style="margin-top: 15px;"></div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-skip" onclick="closeClaimConflict()">OK</button>
                <button class="btn-discard" onclick="forceClaimImage()" id="forceClaimBtn" style="display: none;">Force Claim</button>
            </div>
        </div>
    </div>

    <!-- Already on MO modal -->
    <div class="modal" id="alreadyOnMOModal">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h2>Already on MO</h2>
            <p style="font-size: 13px; color: #888;">
                This image has already been uploaded to Mushroom Observer.
                Select from dropdown or enter an Observation ID (number) or Field Slip Code.
            </p>
            <select class="mo-id-input" id="moIdSelect" style="width: 100%; margin-bottom: 10px;">
                <option value="">-- Select existing --</option>
            </select>
            <input type="text" class="mo-id-input" id="moIdInput" placeholder="Or enter Observation ID or Field Slip Code">
            <div id="moVerificationStatus" class="verification-status" style="display: none;"></div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-approve" onclick="submitAlreadyOnMO()">Submit</button>
                <button class="btn-skip" onclick="closeAlreadyOnMOModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Phase 4 modal - Add to Existing Observation -->
    <div class="modal" id="phase4Modal">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h2>Add to Existing Observation</h2>
            <p style="font-size: 13px; color: #888;">
                Upload this image to an existing MO observation.
                Select from dropdown or enter an Observation ID (number) or Field Slip Code.
            </p>
            <select class="mo-id-input" id="phase4Select" style="width: 100%; margin-bottom: 10px;">
                <option value="">-- Select existing --</option>
            </select>
            <input type="text" class="mo-id-input" id="phase4Input" placeholder="Or enter Observation ID or Field Slip Code">
            <div id="phase4VerificationStatus" class="verification-status" style="display: none;"></div>
            <div id="phase4Status" style="display: none; padding: 10px; border-radius: 4px; font-size: 12px; margin-top: 10px;"></div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-mo-phase4" onclick="uploadPhase4()">Upload</button>
                <button class="btn-skip" onclick="closePhase4Modal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Exclude confirmation modal -->
    <div class="modal" id="excludeModal">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h2>Exclude Images</h2>
            <p style="font-size: 13px; color: #888;">
                This image has <span id="excludeLinkedCount"></span> linked image(s).
            </p>
            <div id="excludeLinkedList" style="max-height: 150px; overflow-y: auto; background: #1e1e1e; padding: 10px; border-radius: 4px; margin: 10px 0; font-size: 12px;">
            </div>
            <p style="font-size: 13px; margin-top: 15px;">
                Do you want to exclude only the current image, or all linked images as well?
            </p>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn-exclude" onclick="excludeCurrentOnly()" style="flex: 1;">Current Only</button>
                <button class="btn-exclude" onclick="excludeAllLinked()" style="flex: 1;">All Linked</button>
                <button class="btn-skip" onclick="closeExcludeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // MO base URL from server config
        const MO_BASE_URL = "{{ mo_base_url }}";

        let currentImage = null;
        let imageList = [];
        let nemfDates = [];
        let peekingImage = null;  // Image currently being peeked at
        let adjacentCache = {};   // Cache adjacent image data
        let navigationState = null;  // Navigation info from backend
        let currentExistingObservations = [];  // Existing observations for current field code
        let currentUser = null;
        let heartbeatInterval = null;

        // Track original values for re-verification
        let originalValues = {
            location: '',
            name: ''
        };

        // Autocomplete state
        let autocompleteTimeout = null;
        let selectedAutocompleteIndex = -1;

        // Setup autocomplete for location field
        function setupAutocomplete() {
            const locationInput = document.getElementById('reviewLocation');
            const locationDropdown = document.getElementById('locationDropdown');
            const nameInput = document.getElementById('reviewName');
            const nameDropdown = document.getElementById('nameDropdown');

            // Location autocomplete
            locationInput.addEventListener('input', (e) => {
                clearTimeout(autocompleteTimeout);
                autocompleteTimeout = setTimeout(() => {
                    fetchAutocomplete('location', e.target.value, locationDropdown);
                }, 300);
            });

            locationInput.addEventListener('focus', () => {
                originalValues.location = locationInput.value;
                if (locationInput.value.length >= 2) {
                    fetchAutocomplete('location', locationInput.value, locationDropdown);
                }
            });

            locationInput.addEventListener('blur', (e) => {
                // Delay to allow click on dropdown item
                setTimeout(async () => {
                    locationDropdown.classList.remove('active');
                    // Re-verify if value changed
                    if (locationInput.value !== originalValues.location) {
                        await verifyField('location', locationInput.value);
                        // Check if we should auto-fill date from foray location
                        await checkAndFillForayDate(locationInput.value);
                    }
                }, 200);
            });

            locationInput.addEventListener('keydown', (e) => {
                handleAutocompleteKeydown(e, locationDropdown, 'location');
            });

            // Name autocomplete
            nameInput.addEventListener('input', (e) => {
                clearTimeout(autocompleteTimeout);
                autocompleteTimeout = setTimeout(() => {
                    fetchAutocomplete('name', e.target.value, nameDropdown);
                }, 300);
            });

            nameInput.addEventListener('focus', () => {
                originalValues.name = nameInput.value;
                if (nameInput.value.length >= 2) {
                    fetchAutocomplete('name', nameInput.value, nameDropdown);
                }
            });

            nameInput.addEventListener('blur', (e) => {
                // Delay to allow click on dropdown item
                setTimeout(() => {
                    nameDropdown.classList.remove('active');
                    // Re-verify if value changed
                    if (nameInput.value !== originalValues.name) {
                        verifyField('name', nameInput.value);
                    }
                }, 200);
            });

            nameInput.addEventListener('keydown', (e) => {
                handleAutocompleteKeydown(e, nameDropdown, 'name');
            });
        }

        async function fetchAutocomplete(type, query, dropdown) {
            if (!query || query.length < 2) {
                dropdown.classList.remove('active');
                return;
            }

            const endpoint = type === 'location' ? '/api/lookup/location' : '/api/lookup/name';
            const results = await fetch(`${endpoint}?q=${encodeURIComponent(query)}`).then(r => r.json());

            if (results.length === 0) {
                dropdown.classList.remove('active');
                return;
            }

            selectedAutocompleteIndex = -1;
            dropdown.innerHTML = results.map((item, idx) => {
                const displayName = type === 'location' ? item.name : item.text_name;
                const author = item.author ? ` <span style="color: #888;">${item.author}</span>` : '';
                return `
                    <div class="autocomplete-item" data-index="${idx}"
                         data-id="${item.id}" data-name="${displayName}"
                         onclick="selectAutocomplete('${type}', '${item.id}', '${displayName.replace(/'/g, "\\'")}')">
                        ${displayName}${author}
                        <span class="match-type ${item.match}">${item.match}</span>
                    </div>
                `;
            }).join('');
            dropdown.classList.add('active');
        }

        function handleAutocompleteKeydown(e, dropdown, type) {
            const items = dropdown.querySelectorAll('.autocomplete-item');
            if (!dropdown.classList.contains('active') || items.length === 0) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedAutocompleteIndex = Math.min(selectedAutocompleteIndex + 1, items.length - 1);
                updateAutocompleteSelection(items);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedAutocompleteIndex = Math.max(selectedAutocompleteIndex - 1, 0);
                updateAutocompleteSelection(items);
            } else if (e.key === 'Enter' && selectedAutocompleteIndex >= 0) {
                e.preventDefault();
                const selected = items[selectedAutocompleteIndex];
                selectAutocomplete(type, selected.dataset.id, selected.dataset.name);
            } else if (e.key === 'Escape') {
                dropdown.classList.remove('active');
            }
        }

        function updateAutocompleteSelection(items) {
            items.forEach((item, idx) => {
                item.classList.toggle('selected', idx === selectedAutocompleteIndex);
            });
            if (selectedAutocompleteIndex >= 0) {
                items[selectedAutocompleteIndex].scrollIntoView({ block: 'nearest' });
            }
        }

        function selectAutocomplete(type, id, name) {
            if (type === 'location') {
                document.getElementById('reviewLocation').value = name;
                document.getElementById('reviewLocationId').value = id;
                document.getElementById('locationDropdown').classList.remove('active');
                updateFieldStatus('locationStatus', 'verified', '‚úì Verified');
                // Trigger auto-lock when selecting from autocomplete
                onFieldInput('reviewLocation', 'lockLocation');
                // Check if we should auto-fill date from foray location
                checkAndFillForayDate(name);
            } else {
                document.getElementById('reviewName').value = name;
                document.getElementById('reviewNameId').value = id;
                document.getElementById('nameDropdown').classList.remove('active');
                updateFieldStatus('nameStatus', 'verified', '‚úì Verified');
                // Trigger auto-lock when selecting from autocomplete
                onFieldInput('reviewName', 'lockName');
            }
        }

        async function verifyField(type, value) {
            if (!value || value.length < 2) {
                updateFieldStatus(type + 'Status', '', '');
                return;
            }

            const statusId = type + 'Status';
            updateFieldStatus(statusId, 'verifying', '‚ü≥ Verifying...');

            const endpoint = type === 'location' ? '/api/lookup/location' : '/api/lookup/name';
            const results = await fetch(`${endpoint}?q=${encodeURIComponent(value)}`).then(r => r.json());

            // Look for exact match (by name, regardless of match type)
            const exactMatch = results.find(r => {
                const matchName = type === 'location' ? r.name : r.text_name;
                return matchName.toLowerCase() === value.toLowerCase();
            });

            if (exactMatch) {
                const displayName = type === 'location' ? exactMatch.name : exactMatch.text_name;
                if (type === 'location') {
                    document.getElementById('reviewLocationId').value = exactMatch.id;
                    document.getElementById('lockLocation').checked = true;
                } else {
                    document.getElementById('reviewNameId').value = exactMatch.id;
                    document.getElementById('lockName').checked = true;
                }
                updateFieldStatus(statusId, 'verified', '‚úì Verified');
            } else if (results.length > 0) {
                // Clear the ID since no exact match
                if (type === 'location') {
                    document.getElementById('reviewLocationId').value = '';
                } else {
                    document.getElementById('reviewNameId').value = '';
                }
                updateFieldStatus(statusId, 'unverified', '‚ö† Not exact match');
            } else {
                if (type === 'location') {
                    document.getElementById('reviewLocationId').value = '';
                } else {
                    document.getElementById('reviewNameId').value = '';
                }
                updateFieldStatus(statusId, 'unverified', '‚úó Not found');
            }
        }

        function updateFieldStatus(elementId, className, text) {
            const el = document.getElementById(elementId);
            el.className = 'field-status ' + className;
            el.textContent = text;
        }

        function searchMO() {
            const nameId = document.getElementById('reviewNameId').value;
            const locationId = document.getElementById('reviewLocationId').value;

            if (!nameId) {
                alert('Please select a valid name from the autocomplete before searching.');
                return;
            }

            // Build MO search URL for NEMF 2025 project (ID 389)
            const params = new URLSearchParams({
                'q[model]': 'Observation',
                'q[names][include_subtaxa]': 'true',
                'q[names][include_synonyms]': 'false',
                'q[projects][]': '389'
            });

            // Add name lookup parameter
            params.append('q[names][lookup][]', nameId);

            // Add location if available
            if (locationId) {
                params.append('q[within_locations][]', locationId);
            }

            const url = `${MO_BASE_URL}/observations?${params.toString()}`;
            window.open(url, '_blank');
        }

        async function checkAndFillForayDate(locationValue) {
            // Only auto-fill if date is empty and location has a value
            const dateInput = document.getElementById('reviewDate');
            if (!dateInput.value && locationValue) {
                try {
                    const response = await fetch(`/api/lookup/foray_date?location=${encodeURIComponent(locationValue)}`);
                    const data = await response.json();
                    if (data.date) {
                        dateInput.value = data.date;
                    }
                } catch (error) {
                    console.error('Error looking up foray date:', error);
                }
            }
        }

        async function verifyFromLinkedImages(linkedImageFilenames) {
            if (!linkedImageFilenames || linkedImageFilenames.length === 0) {
                return;
            }

            const currentLocationId = document.getElementById('reviewLocationId').value;
            const currentNameId = document.getElementById('reviewNameId').value;

            // Only auto-verify if current image doesn't already have verified IDs
            const needLocation = !currentLocationId;
            const needName = !currentNameId;

            if (!needLocation && !needName) {
                return; // Already have both IDs
            }

            // Check each linked image for verified data
            for (const filename of linkedImageFilenames) {
                try {
                    // Fetch linked image data (without claiming or adding to history)
                    const response = await fetch(`/api/image/${encodeURIComponent(filename)}`);
                    const linkedData = await response.json();

                    if (linkedData.error) continue;

                    const linkedRev = linkedData.review;
                    const linkedSrc = linkedData.source;

                    // Check if linked image has verified location
                    if (needLocation) {
                        const linkedLocationId = linkedRev.location_id || linkedSrc.location_id;
                        const linkedLocation = linkedRev.location || linkedSrc.location;
                        if (linkedLocationId && linkedLocation) {
                            // Use linked image's verified location
                            document.getElementById('reviewLocation').value = linkedLocation;
                            document.getElementById('reviewLocationId').value = linkedLocationId;
                            document.getElementById('lockLocation').checked = true;
                            updateFieldStatus('locationStatus', 'verified', '‚úì Verified (from linked)');
                        }
                    }

                    // Check if linked image has verified name
                    if (needName) {
                        const linkedNameId = linkedRev.name_id || linkedSrc.name_id;
                        const linkedName = linkedRev.name || linkedSrc.name;
                        if (linkedNameId && linkedName) {
                            // Use linked image's verified name
                            document.getElementById('reviewName').value = linkedName;
                            document.getElementById('reviewNameId').value = linkedNameId;
                            document.getElementById('lockName').checked = true;
                            updateFieldStatus('nameStatus', 'verified', '‚úì Verified (from linked)');
                        }
                    }

                    // Update original values for change detection
                    originalValues.location = document.getElementById('reviewLocation').value;
                    originalValues.name = document.getElementById('reviewName').value;

                    // If we found both, no need to check more linked images
                    if (document.getElementById('reviewLocationId').value &&
                        document.getElementById('reviewNameId').value) {
                        break;
                    }
                } catch (error) {
                    console.error('Error fetching linked image data:', error);
                }
            }
        }

        function updateReviewFieldSlipLink() {
            const code = document.getElementById('reviewFieldCode').value;
            const link = document.getElementById('reviewFieldSlipLink');
            if (code && code.startsWith('NEMF-')) {
                // Check if field slip exists on MO
                checkFieldSlipExists(code, 'reviewFieldSlipLink');
                // Also look up existing observations for this code
                updateReviewExistingObs(code);
            } else {
                link.style.display = 'none';
                document.getElementById('reviewExistingObsContainer').style.display = 'none';
            }
        }

        async function updateReviewExistingObs(code) {
            const container = document.getElementById('reviewExistingObsContainer');
            const obsDiv = document.getElementById('reviewExistingObs');

            if (!code) {
                container.style.display = 'none';
                currentExistingObservations = [];
                return;
            }

            const results = await fetch(`/api/lookup/existing_observations?code=${encodeURIComponent(code)}`).then(r => r.json());
            currentExistingObservations = results;

            if (results.length > 0) {
                container.style.display = 'block';
                obsDiv.innerHTML = results.map(obs =>
                    `<a href="${obs.url}" target="_blank">#${obs.observation_id}</a> (${obs.owner})`
                ).join(', ');
            } else {
                container.style.display = 'none';
            }
        }

        // Initialize
        async function init() {
            // Set MO links using MO_BASE_URL
            document.getElementById('projectChecklistLink').href = `${MO_BASE_URL}/checklist?project_id=389`;
            document.getElementById('apiKeyLink').href = `${MO_BASE_URL}/account/api_keys`;

            // Get current user
            const whoami = await fetch('/api/whoami').then(r => r.json());
            currentUser = whoami.username;
            document.getElementById('currentUser').textContent = currentUser;

            const status = await fetch('/api/status').then(r => r.json());
            updateSummary(status.summary);
            nemfDates = status.reference.nemf_dates;

            imageList = await fetch('/api/images').then(r => r.json());

            // Setup autocomplete for location and name fields
            setupAutocomplete();

            // Start heartbeat interval (every 2 minutes)
            heartbeatInterval = setInterval(sendHeartbeat, 120000);

            // Listen for page visibility changes to refresh claim when returning to tab
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    // Tab became visible - immediately check claim status
                    sendHeartbeat();
                }
            });

            // Start with first unreviewed image
            const next = await fetch('/api/next-unreviewed').then(r => r.json());
            if (next.filename) {
                loadImage(next.filename);
            } else if (imageList.length > 0) {
                loadImage(imageList[0].filename);
            }
        }

        function updateClaimStatus(claim) {
            const claimStatus = document.getElementById('claimStatus');
            if (claim) {
                if (claim.is_mine) {
                    claimStatus.innerHTML = '<span style="color: #4ecca3;">‚úì You have this image</span>';
                } else if (claim.claimed_by) {
                    claimStatus.innerHTML = `<span style="color: #ff6b6b;">‚ö† Claimed by ${claim.claimed_by}</span>`;
                } else {
                    claimStatus.innerHTML = '';
                }
            } else {
                claimStatus.innerHTML = '';
            }
        }

        function disableActionsIfClaimed(isClaimedByOther, claimedBy) {
            // Get all action buttons and form fields
            const actionButtons = [
                document.getElementById('btnAlreadyOnMO'),
                document.getElementById('btnPhase4'),
                document.getElementById('btnPhase5'),
                document.querySelector('[onclick*="linkImage"]'),
                document.querySelector('[onclick*="submitReview"]')
            ];

            // Get form fields in REVIEW/CORRECTIONS section
            const formFields = [
                document.getElementById('reviewFieldCode'),
                document.getElementById('reviewDate'),
                document.getElementById('reviewDateCustom'),
                document.getElementById('reviewLocation'),
                document.getElementById('reviewLocationId'),
                document.getElementById('reviewName'),
                document.getElementById('reviewNameId'),
                document.getElementById('reviewNotes')
            ];

            if (isClaimedByOther) {
                // Disable actions and form fields
                actionButtons.forEach(btn => {
                    if (btn) {
                        btn.disabled = true;
                        btn.title = `This image is being reviewed by ${claimedBy}`;
                        btn.style.opacity = '0.5';
                        btn.style.cursor = 'not-allowed';
                    }
                });

                formFields.forEach(field => {
                    if (field) {
                        field.disabled = true;
                        field.title = `This image is being reviewed by ${claimedBy}`;
                    }
                });
            } else {
                // Enable actions and form fields
                actionButtons.forEach(btn => {
                    if (btn) {
                        btn.disabled = false;
                        btn.title = '';
                        btn.style.opacity = '1';
                        btn.style.cursor = 'pointer';
                    }
                });

                formFields.forEach(field => {
                    if (field) {
                        field.disabled = false;
                        field.title = '';
                    }
                });
            }
        }

        function handleClaimLoss(claimedBy) {
            if (!currentImage) return;

            // Update the current image's claim status
            currentImage.claim.is_mine = false;
            currentImage.claim.claimed_by = claimedBy;

            // Update UI
            updateClaimStatus(currentImage.claim);

            // Show modal warning
            showClaimConflict(claimedBy, currentImage.filename);
        }

        async function sendHeartbeat() {
            if (currentImage && currentImage.claim?.is_mine) {
                try {
                    const response = await fetch(`/api/image/${encodeURIComponent(currentImage.filename)}/heartbeat`, {
                        method: 'POST'
                    });
                    const data = await response.json();

                    // Check if we lost the claim
                    if (!data.success) {
                        handleClaimLoss(data.claimed_by);
                    }
                } catch (error) {
                    console.error('Heartbeat failed:', error);
                }
            }
        }

        async function loadImage(filename, addToHistory = true) {
            const url = `/api/image/${encodeURIComponent(filename)}${addToHistory ? '?add_to_history=true' : ''}`;
            const data = await fetch(url).then(r => r.json());
            if (data.error) {
                alert(data.error);
                return;
            }

            currentImage = data;
            peekingImage = null;
            closePeek();

            // Update image
            document.getElementById('mainImage').src = `/images/${encodeURIComponent(filename)}`;
            document.getElementById('currentFilename').textContent = filename;

            // Update claim status and disable UI if claimed by someone else
            updateClaimStatus(data.claim);

            // Don't block viewing - only disable actions if someone else has claimed it
            const claimedByOther = data.claim && data.claim.claimed_by && !data.claim.is_mine;
            disableActionsIfClaimed(claimedByOther, data.claim.claimed_by);

            // Update position
            document.getElementById('positionInfo').textContent =
                `${data.nav.current_index + 1}/${data.nav.total}`;

            // Update source data with match indicators
            const src = data.source;
            setSourceField('sourceFieldCode', src.field_code, src.confidence?.['Field Slip Code']);

            // Update field slip link
            const fieldSlipLink = document.getElementById('fieldSlipLink');
            if (src.field_code && src.field_code.startsWith('NEMF-')) {
                // Check if field slip exists on MO
                checkFieldSlipExists(src.field_code);
            } else {
                fieldSlipLink.style.display = 'none';
            }

            setSourceField('sourceDate', src.date, src.confidence?.['Date']);
            setSourceField('sourceLocation', src.location, src.confidence?.['Location']);
            setSourceField('sourceName', src.name, src.confidence?.['ID']);
            document.getElementById('sourceNotes').textContent = src.notes || '-';

            // Update match indicators
            updateMatchIndicator('locationMatchIndicator', src.location_match, src.location_id);
            updateMatchIndicator('nameMatchIndicator', src.name_match, src.name_id);

            // Existing observations (deduplicated)
            const existingContainer = document.getElementById('existingObsContainer');
            const existingObs = document.getElementById('existingObs');
            if (src.existing_observations && src.existing_observations.length > 0) {
                // Deduplicate by observation_id
                const seen = new Set();
                const uniqueObs = src.existing_observations.filter(obs => {
                    if (seen.has(obs.observation_id)) return false;
                    seen.add(obs.observation_id);
                    return true;
                });
                existingContainer.style.display = 'block';
                existingObs.innerHTML = uniqueObs.map(obs =>
                    `<a href="${obs.url}" target="_blank">#${obs.observation_id}</a> (${obs.owner})`
                ).join(', ');
            } else {
                existingContainer.style.display = 'none';
            }

            // Update review fields
            const rev = data.review;
            document.getElementById('reviewFieldCode').value = rev.field_code || src.field_code || '';
            updateReviewFieldSlipLink();
            document.getElementById('reviewDate').value = rev.date || src.date || '';
            document.getElementById('reviewLocation').value = rev.location || src.location || '';
            document.getElementById('reviewLocationId').value = rev.location_id || src.location_id || '';
            document.getElementById('reviewName').value = rev.name || src.name || '';
            document.getElementById('reviewNameId').value = rev.name_id || src.name_id || '';
            document.getElementById('reviewNotes').value = rev.notes || '';

            // Initialize lock checkboxes based on saved state or field content
            // Locks should be checked if field has manually-entered content
            const fieldLocks = rev.field_locks || {};
            document.getElementById('lockFieldCode').checked = fieldLocks.field_code || false;
            document.getElementById('lockDate').checked = fieldLocks.date || false;
            document.getElementById('lockLocation').checked = fieldLocks.location || false;
            document.getElementById('lockName').checked = fieldLocks.name || false;
            document.getElementById('lockNotes').checked = fieldLocks.notes || false;

            // Auto-verify location and name if they have values but no IDs
            const locationValue = document.getElementById('reviewLocation').value;
            const locationId = document.getElementById('reviewLocationId').value;
            const nameValue = document.getElementById('reviewName').value;
            const nameId = document.getElementById('reviewNameId').value;

            if (locationValue && !locationId) {
                // Has location text but no ID - try to auto-verify
                verifyField('location', locationValue);
            } else {
                // Update field verification status based on whether we have ID
                updateFieldStatus('locationStatus', locationId ? 'verified' : '', locationId ? '‚úì Verified' : '');
            }

            if (nameValue && !nameId) {
                // Has name text but no ID - try to auto-verify
                verifyField('name', nameValue);
            } else {
                // Update field verification status based on whether we have ID
                updateFieldStatus('nameStatus', nameId ? 'verified' : '', nameId ? '‚úì Verified' : '');
            }

            // Check if we should auto-fill date from foray location
            if (locationValue) {
                await checkAndFillForayDate(locationValue);
            }

            // Store original values for change detection
            originalValues.location = document.getElementById('reviewLocation').value;
            originalValues.name = document.getElementById('reviewName').value;

            // Linked images
            const linkedField = document.getElementById('linkedImagesField');
            const linkedList = document.getElementById('linkedImagesList');
            if (rev.linked_images && rev.linked_images.length > 0) {
                linkedField.style.display = 'block';
                renderLinkedImages(rev.linked_images);
                // Auto-verify from linked images if current image has no IDs
                await verifyFromLinkedImages(rev.linked_images);
            } else {
                linkedField.style.display = 'none';
            }

            // Status badge
            const badge = document.getElementById('statusBadge');
            if (rev.status) {
                let badgeText = rev.status;
                if (rev.status === 'already_on_mo' && rev.mo_id_value) {
                    if (rev.mo_id_type === 'observation') {
                        badgeText += ` (Obs #${rev.mo_id_value})`;
                    } else if (rev.mo_id_type === 'field_slip') {
                        badgeText += ` (${rev.mo_id_value})`;
                    }
                }
                badge.innerHTML = `<span class="status-badge status-${rev.status}">${badgeText}</span>`;
            } else {
                badge.innerHTML = '';
            }

            // MO Observation link (for Phase 4/5 uploaded images)
            const moObsContainer = document.getElementById('reviewExistingObsContainer');
            const moObsDiv = document.getElementById('reviewExistingObs');
            if (rev.mo_observation_id && rev.mo_observation_url) {
                moObsContainer.style.display = 'block';
                moObsDiv.innerHTML = `<a href="${rev.mo_observation_url}" target="_blank">Observation #${rev.mo_observation_id}</a> (Image #${rev.mo_image_id || 'N/A'})`;
            } else if (rev.status !== 'already_on_mo') {
                // Only hide if not showing "already_on_mo" field slip lookup
                moObsContainer.style.display = 'none';
            }

            // Show uploaded warning
            const uploadWarning = document.getElementById('alreadyUploadedWarning');
            if (rev.mo_observation_id && rev.mo_observation_url) {
                uploadWarning.style.display = 'block';
                uploadWarning.innerHTML = `‚ö†Ô∏è Already uploaded to <a href="${rev.mo_observation_url}" target="_blank">Observation #${rev.mo_observation_id}</a> (Image #${rev.mo_image_id})`;
            } else {
                uploadWarning.style.display = 'none';
            }

            // Load adjacent images
            loadAdjacentImages(filename);

            // Update navigation state
            updateNavigationState();
        }

        function updateMatchIndicator(elementId, matchType, id) {
            const el = document.getElementById(elementId);
            if (matchType === 'exact') {
                el.className = 'match-indicator match-exact';
                el.textContent = '‚úì';
                el.title = `Matched in database (ID: ${id})`;
            } else if (matchType === 'partial') {
                el.className = 'match-indicator match-partial';
                el.textContent = '?';
                el.title = 'Partial match - needs review';
            } else {
                el.className = 'match-indicator match-none';
                el.textContent = '‚úó';
                el.title = 'Not found in database';
            }
        }

        function setSourceField(elementId, value, confidence) {
            const el = document.getElementById(elementId);
            if (!value) {
                el.textContent = '(missing)';
                el.className = 'value missing';
            } else {
                el.textContent = value;
                el.className = confidence === 'low' ? 'value low-confidence' : 'value';
            }
        }

        async function loadAdjacentImages(filename) {
            const adjacent = await fetch(`/api/adjacent/${encodeURIComponent(filename)}`).then(r => r.json());
            adjacentCache = {};
            adjacent.forEach(img => adjacentCache[img.filename] = img);

            const container = document.getElementById('adjacentImages');
            container.innerHTML = adjacent.map(img => `
                <div class="adjacent-thumb ${img.is_current ? 'current' : ''}" data-filename="${img.filename}">
                    <img src="/images/${encodeURIComponent(img.filename)}"
                         onclick="peekImage('${img.filename}')"
                         title="${img.filename}">
                    ${img.field_code ? `<span class="thumb-code">${img.field_code}</span>` : ''}
                    ${!img.is_current ? `<button class="link-btn" onclick="event.stopPropagation(); linkFromImage('${img.filename}')">Link</button>` : ''}
                </div>
            `).join('');
        }

        async function peekImage(filename) {
            if (filename === currentImage.filename) {
                closePeek();
                return;
            }

            // Fetch full data for peeked image
            const data = await fetch(`/api/image/${encodeURIComponent(filename)}`).then(r => r.json());
            if (data.error) return;

            peekingImage = data;

            // Update UI to show peeking
            document.getElementById('peekingIndicator').style.display = 'inline';

            // Highlight peeked thumbnail
            document.querySelectorAll('.adjacent-thumb').forEach(el => {
                el.classList.remove('peeking');
                if (el.dataset.filename === filename) {
                    el.classList.add('peeking');
                }
            });

            // Show peek panel
            const panel = document.getElementById('peekPanel');
            panel.classList.add('active');
            document.getElementById('peekFilename').textContent = filename;
            const peekCode = data.source.field_code || data.review.field_code;
            document.getElementById('peekFieldCode').textContent = peekCode || '(none)';

            // Update peek field slip link
            const peekLink = document.getElementById('peekFieldSlipLink');
            if (peekCode && peekCode.startsWith('NEMF-')) {
                // Check if field slip exists on MO
                checkFieldSlipExists(peekCode, 'peekFieldSlipLink');
            } else {
                peekLink.style.display = 'none';
            }

            document.getElementById('peekDate').textContent = data.source.date || '(none)';
            document.getElementById('peekLocation').textContent = data.source.location || '(none)';
            document.getElementById('peekName').textContent = data.source.name || '(none)';

            // Update claim status
            const peekClaimStatus = document.getElementById('peekClaimStatus');
            if (data.claim && data.claim.claimed_by) {
                if (data.claim.is_mine) {
                    peekClaimStatus.innerHTML = '<span style="color: #4ecca3;">You have this</span>';
                } else {
                    peekClaimStatus.innerHTML = `<span style="color: #ff6b6b;">Claimed by ${data.claim.claimed_by}</span>`;
                }
            } else {
                peekClaimStatus.textContent = 'Unclaimed';
            }

            // Show peeked image in main view temporarily
            document.getElementById('mainImage').src = `/images/${encodeURIComponent(filename)}`;
        }

        function closePeek() {
            peekingImage = null;
            document.getElementById('peekingIndicator').style.display = 'none';
            document.getElementById('peekPanel').classList.remove('active');
            document.querySelectorAll('.adjacent-thumb').forEach(el => el.classList.remove('peeking'));

            // Restore current image
            if (currentImage) {
                document.getElementById('mainImage').src = `/images/${encodeURIComponent(currentImage.filename)}`;
            }
        }

        function onFieldInput(fieldId, lockId) {
            // Auto-check lock when user types into field (if it has content)
            // Auto-uncheck lock when field becomes empty
            const field = document.getElementById(fieldId);
            const lock = document.getElementById(lockId);

            if (!field || !lock) return;

            // Check if field has content
            const hasContent = field.value && field.value.trim() !== '';

            // Auto-check lock if field has content and lock is unchecked
            if (hasContent && !lock.checked) {
                lock.checked = true;
            }
            // Auto-uncheck lock if field is empty
            else if (!hasContent && lock.checked) {
                lock.checked = false;
            }
        }

        function linkFromPeek() {
            if (!peekingImage) return;
            linkFromImage(peekingImage.filename);
        }

        async function linkFromImage(sourceFilename) {
            // Fetch source image data
            const data = await fetch(`/api/image/${encodeURIComponent(sourceFilename)}`).then(r => r.json());
            if (data.error) return;

            const src = data.source;
            const rev = data.review;

            // Copy field data to current review fields (prefer review data if set)
            // Only copy if field is not locked
            if ((src.field_code || rev.field_code) && !document.getElementById('lockFieldCode').checked) {
                document.getElementById('reviewFieldCode').value = rev.field_code || src.field_code;
            }
            if ((src.date || rev.date) && !document.getElementById('lockDate').checked) {
                document.getElementById('reviewDate').value = rev.date || src.date;
            }
            if ((src.location || rev.location) && !document.getElementById('lockLocation').checked) {
                document.getElementById('reviewLocation').value = rev.location || src.location;
                document.getElementById('reviewLocationId').value = rev.location_id || src.location_id || '';
            }
            if ((src.name || rev.name) && !document.getElementById('lockName').checked) {
                document.getElementById('reviewName').value = rev.name || src.name;
                document.getElementById('reviewNameId').value = rev.name_id || src.name_id || '';
            }

            // Verify and lock fields that were copied from linked image
            const copiedLocationId = document.getElementById('reviewLocationId').value;
            const copiedLocationValue = document.getElementById('reviewLocation').value;

            if (copiedLocationValue && !document.getElementById('lockLocation').checked) {
                if (copiedLocationId) {
                    // Has ID from linked image - mark as verified and lock
                    updateFieldStatus('locationStatus', 'verified', '‚úì Verified (from linked)');
                    document.getElementById('lockLocation').checked = true;
                } else {
                    // No ID but has value - try to auto-verify
                    await verifyField('location', copiedLocationValue);
                }
            }

            // Check if we should auto-fill date from foray location
            if (copiedLocationValue) {
                await checkAndFillForayDate(copiedLocationValue);
            }

            const copiedNameId = document.getElementById('reviewNameId').value;
            const copiedNameValue = document.getElementById('reviewName').value;

            if (copiedNameValue && !document.getElementById('lockName').checked) {
                if (copiedNameId) {
                    // Has ID from linked image - mark as verified and lock
                    updateFieldStatus('nameStatus', 'verified', '‚úì Verified (from linked)');
                    document.getElementById('lockName').checked = true;
                } else {
                    // No ID but has value - try to auto-verify
                    await verifyField('name', copiedNameValue);
                }
            }

            // Track linked image
            let linkedImages = currentImage.review.linked_images || [];
            if (!linkedImages.includes(sourceFilename)) {
                linkedImages.push(sourceFilename);
            }
            currentImage.review.linked_images = linkedImages;

            // Update linked images display
            const linkedField = document.getElementById('linkedImagesField');
            linkedField.style.display = 'block';
            renderLinkedImages(linkedImages);

            closePeek();
        }

        function switchToPeek() {
            if (!peekingImage) return;
            loadImage(peekingImage.filename);
        }

        function zoomImage() {
            const modal = document.getElementById('zoomModal');
            const zoomImg = document.getElementById('zoomImage');
            const label = document.getElementById('zoomLabel');

            const filename = peekingImage ? peekingImage.filename : currentImage.filename;
            zoomImg.src = `/images/${encodeURIComponent(filename)}`;
            label.textContent = filename;
            modal.classList.add('active');
        }

        function closeZoom() {
            document.getElementById('zoomModal').classList.remove('active');
        }

        function updateSummary(summary) {
            document.getElementById('totalCount').textContent = summary.total;
            document.getElementById('reviewedCount').textContent = summary.reviewed;
            document.getElementById('approvedCount').textContent = summary.approved;
            document.getElementById('alreadyOnMOCount').textContent = summary.already_on_mo || 0;
            document.getElementById('excludedCount').textContent = summary.excluded;
        }

        async function submitReview(status) {
            if (!currentImage) return;

            const dateSelect = document.getElementById('reviewDate');
            let date = dateSelect.value;
            if (date === 'other') {
                date = document.getElementById('reviewDateCustom').value;
            }

            // Determine if corrections were made
            const src = currentImage.source;
            const fieldCode = document.getElementById('reviewFieldCode').value;
            const location = document.getElementById('reviewLocation').value;
            const name = document.getElementById('reviewName').value;

            const hasCorrections = (
                fieldCode !== (src.field_code || '') ||
                date !== (src.date || '') ||
                location !== (src.location || '') ||
                name !== (src.name || '')
            );

            const finalStatus = (status === 'approved' && hasCorrections) ? 'corrected' : status;

            const reviewData = {
                status: finalStatus,
                field_code: fieldCode,
                date: date,
                location: location,
                location_id: document.getElementById('reviewLocationId').value || null,
                name: name,
                name_id: document.getElementById('reviewNameId').value || null,
                notes: document.getElementById('reviewNotes').value,
                linked_images: currentImage.review.linked_images || [],
                field_locks: {
                    field_code: document.getElementById('lockFieldCode').checked,
                    date: document.getElementById('lockDate').checked,
                    location: document.getElementById('lockLocation').checked,
                    name: document.getElementById('lockName').checked,
                    notes: document.getElementById('lockNotes').checked
                }
            };

            try {
                const response = await fetch(`/api/image/${encodeURIComponent(currentImage.filename)}/review`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(reviewData)
                });

                const data = await response.json();

                if (data.success) {
                    updateSummary(data.summary);
                    loadNextUnreviewedFresh();
                } else if (response.status === 409) {
                    // Claim conflict - lost the claim to another user
                    handleClaimLoss(data.claimed_by);
                    alert(`Cannot submit: This image is now being reviewed by ${data.claimed_by}.\n\nYour changes have NOT been saved.`);
                } else {
                    alert('Failed to submit: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Failed to submit: ' + error.message);
            }
        }

        async function backImage() {
            if (!currentImage || !navigationState) return;
            closePeek();

            if (navigationState.back_target) {
                await loadImage(navigationState.back_target, false); // Don't add to history
            }
        }

        async function forwardImage() {
            if (!currentImage || !navigationState) return;
            closePeek();

            if (navigationState.forward_target) {
                await loadImage(navigationState.forward_target, false); // Don't add to history
            } else if (navigationState.all_resolved) {
                showCelebration();
            }
        }

        async function nextUnreviewedImage() {
            closePeek();

            if (navigationState && navigationState.next_unreviewed) {
                // Add to history only if jumping to priority order, not if in history
                const addToHistory = navigationState.next_unreviewed_mode === 'priority';
                await loadImage(navigationState.next_unreviewed, addToHistory);
            } else if (navigationState && navigationState.all_resolved) {
                showCelebration();
            }
        }

        async function loadNextUnreviewedFresh() {
            // Get fresh next unreviewed image from API (not cached navigationState)
            closePeek();

            try {
                const response = await fetch('/api/next-unreviewed');
                const data = await response.json();

                if (data.filename) {
                    await loadImage(data.filename, true);
                } else if (data.message) {
                    showCelebration();
                }
            } catch (error) {
                console.error('Failed to get next unreviewed image:', error);
            }
        }

        function showCelebration() {
            alert('üéâ All images reviewed! Great work!');
        }

        async function updateNavigationState() {
            if (!currentImage) return;

            try {
                const response = await fetch(`/api/navigation/${encodeURIComponent(currentImage.filename)}`);
                navigationState = await response.json();

                // Update button states
                const btnBack = document.getElementById('btnBack');
                const btnForward = document.getElementById('btnForward');
                const btnNextUnreviewed = document.getElementById('btnNextUnreviewed');

                if (btnBack) {
                    btnBack.disabled = !navigationState.can_go_back;
                    btnBack.style.opacity = navigationState.can_go_back ? '1' : '0.5';
                }

                if (btnForward) {
                    btnForward.disabled = !navigationState.can_go_forward;
                    btnForward.style.opacity = navigationState.can_go_forward ? '1' : '0.5';
                }

                if (btnNextUnreviewed) {
                    btnNextUnreviewed.disabled = navigationState.all_resolved;
                    btnNextUnreviewed.style.opacity = navigationState.all_resolved ? '0.5' : '1';
                }
            } catch (error) {
                console.error('Failed to update navigation state:', error);
            }
        }

        function jumpToImage() {
            document.getElementById('jumpModal').classList.add('active');
            document.getElementById('jumpInput').value = '';
            document.getElementById('jumpError').style.display = 'none';
            document.getElementById('jumpInput').focus();
        }

        function closeJumpModal() {
            document.getElementById('jumpModal').classList.remove('active');
        }

        async function executeJump() {
            const filename = document.getElementById('jumpInput').value.trim();
            if (!filename) return;

            const errorEl = document.getElementById('jumpError');
            errorEl.style.display = 'none';

            // Try to load the image - the API will handle if it doesn't exist
            try {
                const response = await fetch(`/api/image/${encodeURIComponent(filename)}`);
                const data = await response.json();

                if (data.error) {
                    errorEl.textContent = `Image "${filename}" not found`;
                    errorEl.style.display = 'block';
                } else {
                    closeJumpModal();
                    loadImage(filename);
                }
            } catch (error) {
                errorEl.textContent = `Error: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }

        function handleJumpInput(event) {
            if (event.key === 'Escape') {
                closeJumpModal();
                return;
            }
            if (event.key === 'Enter') {
                executeJump();
                return;
            }
        }

        // Date selector
        document.getElementById('reviewDate').addEventListener('change', function() {
            const customDate = document.getElementById('reviewDateCustom');
            customDate.style.display = this.value === 'other' ? 'block' : 'none';
        });

        // Escape key to close modals
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                // Close any open modals
                closeJumpModal();
                closeZoom();
                closePeek();
                closeAlreadyOnMOModal();
                closePhase4Modal();
                closeExcludeModal();
                closeSettings();
                closeClaimConflict();

                // If in input field, blur it
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
                    e.target.blur();
                }
            }
        });

        // Settings modal
        async function showSettings() {
            const settings = await fetch('/api/settings').then(r => r.json());
            document.getElementById('settingsUsername').value = settings.username;
            document.getElementById('settingsApiKey').value = settings.api_key || '';
            document.getElementById('settingsPassword').value = '';
            document.getElementById('settingsModal').classList.add('active');
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
        }

        async function saveSettings() {
            const apiKey = document.getElementById('settingsApiKey').value;
            const password = document.getElementById('settingsPassword').value;

            const data = { api_key: apiKey };
            if (password) data.password = password;

            const response = await fetch('/api/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(data)
            }).then(r => r.json());

            if (response.success) {
                closeSettings();
                if (password) {
                    alert('Settings saved. You may need to re-login with your new password.');
                }
            } else {
                alert('Failed to save settings: ' + (response.error || 'Unknown error'));
            }
        }

        // Claim conflict modal
        let pendingClaimFilename = null;

        function showClaimConflict(claimedBy, filename) {
            pendingClaimFilename = filename;
            document.getElementById('claimConflictMessage').textContent =
                `This image is currently being reviewed by ${claimedBy}. Please coordinate with them before making changes.`;
            document.getElementById('claimConflictDetails').innerHTML =
                `<p>You can:</p>
                <ul style="margin-left: 20px; color: #888;">
                    <li>Wait for them to finish</li>
                    <li>Skip to another image</li>
                    <li>Contact ${claimedBy} to coordinate</li>
                </ul>`;
            document.getElementById('claimConflictModal').classList.add('active');
        }

        function closeClaimConflict() {
            document.getElementById('claimConflictModal').classList.remove('active');
            pendingClaimFilename = null;
        }

        async function forceClaimImage() {
            // Not implemented for initial version - users coordinate manually
            closeClaimConflict();
        }

        // Already on MO modal functions
        async function openAlreadyOnMOModal() {
            if (!currentImage) return;

            document.getElementById('alreadyOnMOModal').classList.add('active');
            document.getElementById('moIdInput').value = '';
            document.getElementById('moVerificationStatus').style.display = 'none';

            // Build suggestions from current image data
            const suggestions = [];

            // Add field slip code from review form (only if it exists on MO)
            const fieldCode = document.getElementById('reviewFieldCode').value.trim();
            if (fieldCode && fieldCode.startsWith('NEMF-')) {
                const fieldSlipExists = await checkFieldSlipExistsForSuggestions(fieldCode);
                if (fieldSlipExists) {
                    suggestions.push(fieldCode);
                }
            }

            // Add observation IDs from currentExistingObservations
            currentExistingObservations.forEach(obs => {
                if (obs.observation_id) {
                    suggestions.push(obs.observation_id.toString());
                }
            });

            // Populate select dropdown
            const select = document.getElementById('moIdSelect');
            select.innerHTML = '';
            suggestions.forEach(item => {
                const option = document.createElement('option');
                option.value = item;
                option.textContent = item;
                select.appendChild(option);
            });

            // Set default value to first suggestion if available
            const input = document.getElementById('moIdInput');
            if (suggestions.length > 0) {
                select.value = suggestions[0];
                input.value = '';
            } else {
                input.value = '';
            }

            // When user selects from dropdown, blank the text input
            select.onchange = function() {
                input.value = '';
                document.getElementById('moVerificationStatus').style.display = 'none';
            };

            // When user types in text input, reset dropdown
            input.oninput = function() {
                if (this.value) {
                    select.value = '';
                }
                document.getElementById('moVerificationStatus').style.display = 'none';
            };

            input.focus();
            input.select();
        }

        function closeAlreadyOnMOModal() {
            document.getElementById('alreadyOnMOModal').classList.remove('active');
        }

        async function verifyMOId(idType, idValue) {
            const statusEl = document.getElementById('moVerificationStatus');
            statusEl.style.display = 'block';
            statusEl.className = 'verification-status verifying';
            statusEl.textContent = 'Verifying...';

            try {
                const response = await fetch(
                    `/api/verify_mo_id?type=${idType}&id=${encodeURIComponent(idValue)}`
                );
                const data = await response.json();

                if (data.exists) {
                    statusEl.className = 'verification-status success';
                    if (idType === 'observation') {
                        statusEl.textContent = `‚úì Observation #${idValue} exists`;
                    } else if (idType === 'field_slip') {
                        statusEl.textContent = `‚úì Field Slip "${idValue}" exists`;
                    }
                    return true;
                } else {
                    statusEl.className = 'verification-status error';
                    if (idType === 'observation') {
                        statusEl.textContent = `‚úó Observation #${idValue} not found`;
                    } else if (idType === 'field_slip') {
                        statusEl.textContent = `‚úó Field Slip "${idValue}" not found`;
                    }
                    return false;
                }
            } catch (error) {
                statusEl.className = 'verification-status error';
                statusEl.textContent = '‚úó Verification failed: ' + error.message;
                return false;
            }
        }

        function parseMOIdFromInput(input) {
            // Parse MO ID from input - can be URL, observation ID, or field slip code
            input = input.trim();

            // Get expected hostname from MO_BASE_URL
            const moUrl = new URL(MO_BASE_URL);
            const expectedHostname = moUrl.hostname;

            // Try to parse as URL
            try {
                const url = new URL(input);
                if (url.hostname === expectedHostname ||
                    url.hostname === 'mushroomobserver.org' ||
                    url.hostname === 'www.mushroomobserver.org') {
                    const path = url.pathname;

                    // Match patterns like /observations/12345
                    let match = path.match(/\/(observations?)\/(\d+)/i);
                    if (match) {
                        return { type: 'observation', id: match[2] };
                    }

                    // Match pattern like /588804 (just number in path)
                    match = path.match(/^\/(\d+)$/);
                    if (match) {
                        return { type: 'observation', id: match[1] };
                    }
                }
            } catch (e) {
                // Not a valid URL, continue to try as plain ID
            }

            // If it's all numeric, treat as observation ID
            if (/^\d+$/.test(input)) {
                return { type: 'observation', id: input };
            }

            // Otherwise treat as field slip code
            if (input.length > 0) {
                return { type: 'field_slip', id: input };
            }

            return null;
        }

        async function submitAlreadyOnMO() {
            if (!currentImage) return;

            // Check dropdown first, then text input
            const select = document.getElementById('moIdSelect');
            const input = document.getElementById('moIdInput');
            const rawInput = (input.value.trim() || select.value).trim();

            if (!rawInput) {
                alert('Please select from dropdown or enter an ID');
                return;
            }

            // Parse the input
            const parsed = parseMOIdFromInput(rawInput);
            if (!parsed) {
                alert('Invalid input. Please enter a valid Observation ID or Field Slip Code.');
                return;
            }

            // Type is automatically determined by parseMOIdFromInput
            const idType = parsed.type;
            const idValue = parsed.id;

            // Verify the ID exists
            const isValid = await verifyMOId(idType, idValue);
            if (!isValid) {
                return;
            }

            // Collect the review data
            const reviewData = {
                status: 'already_on_mo',
                mo_id_type: idType,
                mo_id_value: idValue,
                field_code: document.getElementById('reviewFieldCode').value.trim(),
                date: document.getElementById('reviewDate').value,
                location: document.getElementById('reviewLocation').value.trim(),
                location_id: document.getElementById('reviewLocation').dataset.locationId || null,
                name: document.getElementById('reviewName').value.trim(),
                name_id: document.getElementById('reviewName').dataset.nameId || null,
                notes: document.getElementById('reviewNotes').value.trim()
            };

            try {
                const response = await fetch(
                    `/api/image/${encodeURIComponent(currentImage.filename)}/review`,
                    {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(reviewData)
                    }
                );

                const data = await response.json();

                if (data.success) {
                    closeAlreadyOnMOModal();
                    updateSummary(data.summary);
                    loadNextUnreviewedFresh();
                } else if (response.status === 409) {
                    // Claim conflict - lost the claim to another user
                    closeAlreadyOnMOModal();
                    handleClaimLoss(data.claimed_by);
                    alert(`Cannot submit: This image is now being reviewed by ${data.claimed_by}.\n\nYour changes have NOT been saved.`);
                } else {
                    alert('Failed to submit: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Failed to submit: ' + error.message);
            }
        }

        // Phase 4 - Add to Existing Observation
        async function openPhase4Modal() {
            if (!currentImage) return;

            document.getElementById('phase4Modal').classList.add('active');
            document.getElementById('phase4Input').value = '';
            document.getElementById('phase4VerificationStatus').style.display = 'none';
            document.getElementById('phase4Status').style.display = 'none';

            // Build suggestions from current image data
            const suggestions = [];

            // Add field slip code from review form (only if it exists on MO)
            const fieldCode = document.getElementById('reviewFieldCode').value.trim();
            if (fieldCode && fieldCode.startsWith('NEMF-')) {
                const fieldSlipExists = await checkFieldSlipExistsForSuggestions(fieldCode);
                if (fieldSlipExists) {
                    suggestions.push(fieldCode);
                }
            }

            // Add observation IDs from currentExistingObservations
            currentExistingObservations.forEach(obs => {
                if (obs.observation_id) {
                    suggestions.push(obs.observation_id.toString());
                }
            });

            // Populate select dropdown
            const select = document.getElementById('phase4Select');
            select.innerHTML = '';
            suggestions.forEach((item, index) => {
                const option = document.createElement('option');
                option.value = item;
                option.textContent = item;
                select.appendChild(option);
            });

            // Default to first item if available
            if (suggestions.length > 0) {
                select.value = suggestions[0];
            }

            // Coordinate select and input interaction
            select.onchange = function() {
                document.getElementById('phase4Input').value = '';
                document.getElementById('phase4VerificationStatus').style.display = 'none';
            };

            const input = document.getElementById('phase4Input');
            input.oninput = function() {
                if (this.value) {
                    select.value = '';
                }
                document.getElementById('phase4VerificationStatus').style.display = 'none';
            };

            input.focus();
            input.select();
        }

        function closePhase4Modal() {
            document.getElementById('phase4Modal').classList.remove('active');
        }

        function confirmExclude() {
            if (!currentImage) return;

            const linkedImages = currentImage.review.linked_images || [];

            if (linkedImages.length === 0) {
                // No linked images - proceed with normal exclude
                submitReview('excluded');
                return;
            }

            // Show modal asking what to exclude
            const modal = document.getElementById('excludeModal');
            document.getElementById('excludeLinkedCount').textContent = linkedImages.length;

            const listDiv = document.getElementById('excludeLinkedList');
            listDiv.innerHTML = linkedImages.map(fn => `<div>‚Ä¢ ${fn}</div>`).join('');

            modal.classList.add('active');
        }

        function closeExcludeModal() {
            document.getElementById('excludeModal').classList.remove('active');
        }

        async function excludeCurrentOnly() {
            if (!currentImage) return;

            const linkedImages = currentImage.review.linked_images || [];
            if (linkedImages.length === 0) {
                closeExcludeModal();
                submitReview('excluded');
                return;
            }

            // Unlink all linked images
            for (const targetFilename of linkedImages) {
                try {
                    await fetch(`/api/unlink/${encodeURIComponent(currentImage.filename)}`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ target: targetFilename })
                    });
                } catch (error) {
                    console.error('Failed to unlink:', error);
                }
            }

            // Update local state
            currentImage.review.linked_images = [];

            closeExcludeModal();

            // Now exclude only the current image
            submitReview('excluded');
        }

        async function excludeAllLinked() {
            closeExcludeModal();
            // Use normal submit which includes linked_images
            submitReview('excluded');
        }

        async function resetReview() {
            if (!currentImage) return;

            if (!confirm(`Reset ${currentImage.filename} to unreviewed?\n\nThis will clear the review status and make it available for review again.`)) {
                return;
            }

            try {
                const response = await fetch(`/api/image/${encodeURIComponent(currentImage.filename)}/reset`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'}
                });

                const data = await response.json();

                if (data.success) {
                    // Reload the current image to reflect the reset state
                    await loadImage(currentImage.filename, false);
                    alert('Review reset successfully. Image is now unreviewed.');
                } else if (response.status === 409) {
                    handleClaimLoss(data.claimed_by);
                    alert(`Cannot reset: This image is now being reviewed by ${data.claimed_by}.`);
                } else {
                    alert('Failed to reset: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Failed to reset: ' + error.message);
            }
        }

        async function resolveFieldSlipToObservation(fieldSlipCode) {
            /**
             * Look up a field slip code and return its observation ID.
             * Returns null if the field slip doesn't exist or isn't linked to an observation.
             */
            try {
                const response = await fetch(`/api/lookup/field_slip_observation?code=${encodeURIComponent(fieldSlipCode)}`);
                const data = await response.json();

                console.log('Field slip lookup response:', data);

                if (data.observation_id) {
                    return data.observation_id;
                }

                // Log debug data if available
                if (data.debug_data) {
                    console.log('Field slip data from API:', data.debug_data);
                }

                return null;
            } catch (error) {
                console.error('Field slip lookup error:', error);
                return null;
            }
        }

        async function checkFieldSlipExistsForSuggestions(fieldSlipCode) {
            /**
             * Check if a field slip exists on MO.
             * Returns true if exists, false if doesn't exist.
             * Used for filtering dropdown suggestions.
             */
            try {
                const response = await fetch(
                    `/api/verify_mo_id?type=field_slip&id=${encodeURIComponent(fieldSlipCode)}`
                );
                const data = await response.json();
                return data.exists || false;
            } catch (error) {
                console.error('Field slip existence check error:', error);
                return false;
            }
        }

        async function checkFieldSlipExists(fieldSlipCode, linkElementId = 'fieldSlipLink') {
            /**
             * Check if a field slip exists on MO and update the link accordingly.
             * Shows "View on MO" link if exists, "NOT ON MO" text if doesn't exist.
             */
            const fieldSlipLink = document.getElementById(linkElementId);

            try {
                const response = await fetch(
                    `/api/verify_mo_id?type=field_slip&id=${encodeURIComponent(fieldSlipCode)}`
                );
                const data = await response.json();

                if (data.exists) {
                    // Field slip exists - show as link
                    fieldSlipLink.href = `${MO_BASE_URL}/qr/${fieldSlipCode}`;
                    fieldSlipLink.textContent = 'View on MO';
                    fieldSlipLink.style.pointerEvents = 'auto';
                    fieldSlipLink.style.textDecoration = 'underline';
                    fieldSlipLink.style.cursor = 'pointer';
                    fieldSlipLink.style.color = '#74b9ff';
                    fieldSlipLink.style.display = 'inline';
                } else {
                    // Field slip doesn't exist - show as plain text
                    fieldSlipLink.removeAttribute('href');
                    fieldSlipLink.textContent = 'NOT ON MO';
                    fieldSlipLink.style.pointerEvents = 'none';
                    fieldSlipLink.style.textDecoration = 'none';
                    fieldSlipLink.style.cursor = 'default';
                    fieldSlipLink.style.color = '#888';
                    fieldSlipLink.style.display = 'inline';
                }
            } catch (error) {
                console.error('Field slip existence check error:', error);
                // On error, hide the link
                fieldSlipLink.style.display = 'none';
            }
        }

        async function verifyPhase4Input(idType, idValue) {
            const statusEl = document.getElementById('phase4VerificationStatus');
            statusEl.style.display = 'block';
            statusEl.className = 'verification-status verifying';
            statusEl.textContent = 'Verifying...';

            try {
                const response = await fetch(
                    `/api/verify_mo_id?type=${idType}&id=${encodeURIComponent(idValue)}`
                );
                const data = await response.json();

                if (data.exists) {
                    statusEl.className = 'verification-status success';
                    if (idType === 'observation') {
                        statusEl.textContent = `‚úì Observation #${idValue} exists`;
                    } else if (idType === 'field_slip') {
                        statusEl.textContent = `‚úì Field Slip "${idValue}" exists`;
                    }
                    return true;
                } else {
                    statusEl.className = 'verification-status error';
                    if (idType === 'observation') {
                        statusEl.textContent = `‚úó Observation #${idValue} not found`;
                    } else if (idType === 'field_slip') {
                        statusEl.textContent = `‚úó Field Slip "${idValue}" not found`;
                    }
                    return false;
                }
            } catch (error) {
                statusEl.className = 'verification-status error';
                statusEl.textContent = '‚úó Verification failed: ' + error.message;
                return false;
            }
        }

        async function uploadPhase4() {
            if (!currentImage) return;

            // Check dropdown first, then text input
            const select = document.getElementById('phase4Select');
            const input = document.getElementById('phase4Input');
            const rawInput = (input.value.trim() || select.value).trim();

            if (!rawInput) {
                alert('Please select from dropdown or enter an ID');
                return;
            }

            // Parse the input
            const parsed = parseMOIdFromInput(rawInput);
            if (!parsed) {
                alert('Invalid input. Please enter a valid Observation ID or Field Slip Code.');
                return;
            }

            const idType = parsed.type;
            const idValue = parsed.id;

            // Verify the ID exists
            const isValid = await verifyPhase4Input(idType, idValue);
            if (!isValid) {
                return;
            }

            // If it's a field slip, resolve to observation ID
            let observationId;
            if (idType === 'field_slip') {
                observationId = await resolveFieldSlipToObservation(idValue);
                if (!observationId) {
                    alert(`Field slip "${idValue}" exists but is not linked to an observation.\n\nPlease use an observation ID instead, or check the browser console for debug information.`);
                    return;
                }
            } else {
                observationId = parseInt(idValue);
            }

            // Check if already uploaded
            const rev = currentImage.review;
            if (rev.mo_observation_id && rev.mo_observation_url) {
                const message = `This image has already been uploaded to Observation #${rev.mo_observation_id} (Image #${rev.mo_image_id}).\n\n` +
                    `Are you sure you want to upload it again? This will create a duplicate image on MO.`;
                if (!confirm(message)) {
                    return;
                }
            }

            const statusEl = document.getElementById('phase4Status');
            statusEl.style.display = 'block';
            statusEl.className = 'mo-status-loading';
            statusEl.textContent = 'Uploading image to MO...';

            const uploadData = {
                filename: currentImage.filename,
                observation_id: observationId,
                field_code: document.getElementById('reviewFieldCode').value.trim(),
                project_id: 389
            };

            try {
                const response = await fetch(
                    '/api/mo/add_to_existing',
                    {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(uploadData)
                    }
                );

                const data = await response.json();

                if (data.success) {
                    const imageCount = data.uploaded_images ? data.uploaded_images.length : 1;
                    const imageText = imageCount === 1 ? '1 image' : `${imageCount} images`;

                    statusEl.className = 'mo-status-success';
                    statusEl.innerHTML = `‚úì Success! Uploaded ${imageText}<br>` +
                        `<a href="${data.observation_url}" target="_blank" style="color: #000; text-decoration: underline;">View Observation #${data.observation_id}</a>`;

                    // Submit review with MO metadata for main image
                    const reviewResult = await submitReviewWithMOData(
                        data.observation_id,
                        data.image_id,
                        data.observation_url
                    );

                    // Update reviews for all linked images
                    await updateLinkedImagesReviews(
                        data.uploaded_images,
                        data.observation_id,
                        data.observation_url
                    );

                    setTimeout(() => {
                        closePhase4Modal();
                        if (reviewResult && reviewResult.summary) {
                            updateSummary(reviewResult.summary);
                        }
                        loadNextUnreviewedFresh();
                    }, 1500);
                } else {
                    statusEl.className = 'mo-status-error';
                    statusEl.textContent = '‚úó Error: ' + (data.error || 'Unknown error');
                }
            } catch (error) {
                statusEl.className = 'mo-status-error';
                statusEl.textContent = '‚úó Error: ' + error.message;
            }
        }

        // Phase 5 - Create New Observation
        async function uploadPhase5() {
            if (!currentImage) return;

            const dateSelect = document.getElementById('reviewDate');
            let date = dateSelect.value;
            if (date === 'other') {
                date = document.getElementById('reviewDateCustom').value;
            }

            if (!date) {
                alert('Please select or enter a date');
                return;
            }

            // Check if already uploaded
            const rev = currentImage.review;
            if (rev.mo_observation_id && rev.mo_observation_url) {
                const message = `This image has already been uploaded to Observation #${rev.mo_observation_id} (Image #${rev.mo_image_id}).\n\n` +
                    `Are you sure you want to upload it again? This will create a duplicate image on MO.`;
                if (!confirm(message)) {
                    return;
                }
            }

            const statusEl = document.getElementById('moUploadStatus');
            statusEl.style.display = 'block';
            statusEl.className = 'mo-status-loading';
            statusEl.textContent = 'Creating new observation on MO...';

            const uploadData = {
                filename: currentImage.filename,
                field_code: document.getElementById('reviewFieldCode').value.trim(),
                date: date,
                location_id: parseInt(document.getElementById('reviewLocationId').value) || null,
                name_id: parseInt(document.getElementById('reviewNameId').value) || null,
                notes: document.getElementById('reviewNotes').value.trim(),
                project_id: 389
            };

            try {
                const response = await fetch(
                    '/api/mo/create_new',
                    {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(uploadData)
                    }
                );

                const data = await response.json();

                if (data.success) {
                    const imageCount = data.uploaded_images ? data.uploaded_images.length : 1;
                    const imageText = imageCount === 1 ? '1 image' : `${imageCount} images`;

                    statusEl.className = 'mo-status-success';
                    statusEl.innerHTML = `‚úì Success! Created observation with ${imageText}<br>` +
                        `<a href="${data.observation_url}" target="_blank" style="color: #000; text-decoration: underline;">View Observation #${data.observation_id}</a>`;

                    // Submit review with MO metadata for main image
                    const reviewResult = await submitReviewWithMOData(
                        data.observation_id,
                        data.image_id,
                        data.observation_url
                    );

                    // Update reviews for all linked images
                    await updateLinkedImagesReviews(
                        data.uploaded_images,
                        data.observation_id,
                        data.observation_url
                    );

                    setTimeout(() => {
                        if (reviewResult && reviewResult.summary) {
                            updateSummary(reviewResult.summary);
                        }
                        loadNextUnreviewedFresh();
                    }, 1500);
                } else {
                    statusEl.className = 'mo-status-error';
                    statusEl.textContent = '‚úó Error: ' + (data.error || 'Unknown error');
                }
            } catch (error) {
                statusEl.className = 'mo-status-error';
                statusEl.textContent = '‚úó Error: ' + error.message;
            }
        }

        // Submit review with MO observation/image metadata
        async function submitReviewWithMOData(observationId, imageId, observationUrl) {
            if (!currentImage) return;

            const dateSelect = document.getElementById('reviewDate');
            let date = dateSelect.value;
            if (date === 'other') {
                date = document.getElementById('reviewDateCustom').value;
            }

            // Determine if corrections were made
            const src = currentImage.source;
            const fieldCode = document.getElementById('reviewFieldCode').value;
            const location = document.getElementById('reviewLocation').value;
            const name = document.getElementById('reviewName').value;

            const hasCorrections = (
                fieldCode !== (src.field_code || '') ||
                date !== (src.date || '') ||
                location !== (src.location || '') ||
                name !== (src.name || '')
            );

            const finalStatus = hasCorrections ? 'corrected' : 'approved';

            const reviewData = {
                status: finalStatus,
                field_code: fieldCode,
                date: date,
                location: location,
                location_id: document.getElementById('reviewLocationId').value || null,
                name: name,
                name_id: document.getElementById('reviewNameId').value || null,
                notes: document.getElementById('reviewNotes').value,
                linked_images: currentImage.review.linked_images || [],
                mo_observation_id: observationId,
                mo_image_id: imageId,
                mo_observation_url: observationUrl,
                field_locks: {
                    field_code: document.getElementById('lockFieldCode').checked,
                    date: document.getElementById('lockDate').checked,
                    location: document.getElementById('lockLocation').checked,
                    name: document.getElementById('lockName').checked,
                    notes: document.getElementById('lockNotes').checked
                }
            };

            const response = await fetch(
                `/api/image/${encodeURIComponent(currentImage.filename)}/review`,
                {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(reviewData)
                }
            );

            const data = await response.json();
            if (!data.success) {
                console.error('Failed to save review data:', data.error);
            }
            return data;
        }

        // Update all linked images' reviews after upload
        async function updateLinkedImagesReviews(uploadedImages, observationId, observationUrl) {
            /**
             * Update review data for all linked images that were uploaded.
             * uploadedImages is an array of {filename, image_id} objects.
             */
            if (!uploadedImages || uploadedImages.length <= 1) {
                // No linked images to update (only main image)
                return;
            }

            // Skip the first image (main image) and update the rest (linked images)
            const linkedImages = uploadedImages.slice(1);

            for (const img of linkedImages) {
                try {
                    // Prepare review data for linked image
                    const reviewData = {
                        status: 'approved',  // Linked images are auto-approved
                        mo_observation_id: observationId,
                        mo_image_id: img.image_id,
                        mo_observation_url: observationUrl
                    };

                    // Submit review for this linked image
                    const response = await fetch(
                        `/api/image/${encodeURIComponent(img.filename)}/review`,
                        {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(reviewData)
                        }
                    );

                    const data = await response.json();
                    if (!data.success) {
                        console.error(`Failed to update review for linked image ${img.filename}:`, data.error);
                    } else {
                        console.log(`Updated review for linked image ${img.filename}`);
                    }
                } catch (error) {
                    console.error(`Error updating linked image ${img.filename}:`, error);
                }
            }
        }

        function showMOUploadStatus(type, message) {
            const statusEl = document.getElementById('moUploadStatus');
            statusEl.style.display = 'block';
            statusEl.className = type === 'success' ? 'mo-status-success' : 'mo-status-error';
            statusEl.textContent = type === 'success' ? '‚úì ' + message : '‚úó ' + message;

            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 5000);
        }

        // Render linked images with unlink buttons
        function renderLinkedImages(linkedImages) {
            const linkedList = document.getElementById('linkedImagesList');
            linkedList.innerHTML = '';

            if (!linkedImages || linkedImages.length === 0) {
                return;
            }

            linkedImages.forEach(filename => {
                const item = document.createElement('div');
                item.className = 'linked-image-item';

                const name = document.createElement('span');
                name.className = 'linked-image-name';
                name.textContent = filename;

                const unlinkBtn = document.createElement('button');
                unlinkBtn.className = 'btn-unlink';
                unlinkBtn.textContent = 'Unlink';
                unlinkBtn.onclick = () => unlinkImage(filename);

                item.appendChild(name);
                item.appendChild(unlinkBtn);
                linkedList.appendChild(item);
            });
        }

        // Unlink an image
        async function unlinkImage(targetFilename) {
            if (!currentImage) return;

            if (!confirm(`Unlink ${targetFilename} from this image?`)) {
                return;
            }

            try {
                const response = await fetch(
                    `/api/unlink/${encodeURIComponent(currentImage.filename)}`,
                    {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ target: targetFilename })
                    }
                );

                const data = await response.json();

                if (data.success) {
                    currentImage.review.linked_images = data.linked_images;

                    if (data.linked_images.length > 0) {
                        renderLinkedImages(data.linked_images);
                    } else {
                        document.getElementById('linkedImagesField').style.display = 'none';
                    }
                } else {
                    alert('Failed to unlink: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Failed to unlink: ' + error.message);
            }
        }

        // Update linkFromImage to check claims first
        const originalLinkFromImage = linkFromImage;
        linkFromImage = async function(sourceFilename) {
            // Try to claim both images
            const response = await fetch(`/api/link/${encodeURIComponent(currentImage.filename)}`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ target: sourceFilename })
            }).then(r => r.json());

            if (!response.success) {
                if (response.failed_claims) {
                    const failed = response.failed_claims.map(f =>
                        `${f.filename} (claimed by ${f.claimed_by})`
                    ).join(', ');
                    alert(`Cannot link: ${failed}\n\nPlease coordinate with the other reviewer.`);
                } else {
                    alert('Failed to link: ' + (response.error || 'Unknown error'));
                }
                return;
            }

            // Now do the actual linking
            const data = await fetch(`/api/image/${encodeURIComponent(sourceFilename)}`).then(r => r.json());
            if (data.error) return;

            const src = data.source;
            const rev = data.review;

            // Copy field data to current review fields (prefer review data if set)
            // Only copy if field is not locked
            if ((src.field_code || rev.field_code) && !document.getElementById('lockFieldCode').checked) {
                document.getElementById('reviewFieldCode').value = rev.field_code || src.field_code;
                updateReviewFieldSlipLink();
            }
            if ((src.date || rev.date) && !document.getElementById('lockDate').checked) {
                document.getElementById('reviewDate').value = rev.date || src.date;
            }
            if ((src.location || rev.location) && !document.getElementById('lockLocation').checked) {
                document.getElementById('reviewLocation').value = rev.location || src.location;
                document.getElementById('reviewLocationId').value = rev.location_id || src.location_id || '';
            }
            if ((src.name || rev.name) && !document.getElementById('lockName').checked) {
                document.getElementById('reviewName').value = rev.name || src.name;
                document.getElementById('reviewNameId').value = rev.name_id || src.name_id || '';
            }

            // Verify and lock fields that were copied from linked image
            const copiedLocationId = document.getElementById('reviewLocationId').value;
            const copiedLocationValue = document.getElementById('reviewLocation').value;

            if (copiedLocationValue && !document.getElementById('lockLocation').checked) {
                if (copiedLocationId) {
                    updateFieldStatus('locationStatus', 'verified', '‚úì Verified (from linked)');
                    document.getElementById('lockLocation').checked = true;
                } else {
                    await verifyField('location', copiedLocationValue);
                }
            }

            // Check if we should auto-fill date from foray location
            if (copiedLocationValue) {
                await checkAndFillForayDate(copiedLocationValue);
            }

            const copiedNameId = document.getElementById('reviewNameId').value;
            const copiedNameValue = document.getElementById('reviewName').value;

            if (copiedNameValue && !document.getElementById('lockName').checked) {
                if (copiedNameId) {
                    updateFieldStatus('nameStatus', 'verified', '‚úì Verified (from linked)');
                    document.getElementById('lockName').checked = true;
                } else {
                    await verifyField('name', copiedNameValue);
                }
            }

            let linkedImages = currentImage.review.linked_images || [];
            if (!linkedImages.includes(sourceFilename)) {
                linkedImages.push(sourceFilename);
            }
            currentImage.review.linked_images = linkedImages;

            const linkedField = document.getElementById('linkedImagesField');
            linkedField.style.display = 'block';
            renderLinkedImages(linkedImages);

            closePeek();
        };

        // Initialize on load
        init();
    </script>
</body>
</html>
